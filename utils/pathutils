#updates the bodys and joints with their identifying integers
function map_path!(Bs, Us, body_id, joint_id)
    
    #loop over each of these bodies
    for B in Bs        
        if !isa(B,WorldFrame) #starting with worldframe but dont want it in the body path table, but want to mark the joint
            #increment body counter and set to this body
            body_id += 1
            B.id = body_id
        end
        #find all outer connections of the body
        Uₒ = Us[map(x -> x.Bᵢ === B, Us)]
        #loop over outer connections, number joints, and map outer bodies
        for U in Uₒ
            joint_id += 1
            U.G.id = joint_id
            body_id, joint_id = map_path!([U.Bₒ], Us, body_id, joint_id)
        end
    end
    #return counters with updated values
    return body_id, joint_id
end

#over load show to make pathtale printing pretty
function Base.show(io::IO, path::PathTable)
    #copy it so matrix version is still readable on sys
    path_table = copy(path.string_table)
    #make each element length 5 by filling with white space
    for i in eachindex(path_table)
        space_to_add = 7 - length(path_table[i])
        if (space_to_add == 7) && (i != 1)
            path_table[i] = "."*repeat(" ", space_to_add-1)
        else
            path_table[i] *= repeat(" ", space_to_add)
        end
    end
    for row in eachrow(path_table)
        println(io, join(row), "    ")
    end
end

#creates the table to be stored in sys
function body_path(B, U)
    table = fill("", (length(B) + 1, length(B) + 1))
    bt = falses(length(B), length(B))
    for body in B
        table[1, body.id+1] = string(body.name) #label column
        table[body.id+1, 1] = string(body.name) #label row
        table[body.id+1, body.id+1] = "x" #mark diagonal element
        bt[body.id, body.id] = true
        path = get_body_path(body, U)
        for inner_body in path
            table[body.id+1, inner_body.id+1] = "x" #mark inner body elements
            bt[body.id, inner_body.id] = true #mark inner body elements
        end
    end
    PathTable(table, bt)
end

#returns all bodies in another bodies path
function get_body_path(Bₒ, Us; path=[]) #call without path, path is applied recursively
    U = find_U_by_Bₒ(Bₒ, Us)    
    if !isa(U.Bᵢ, WorldFrame) #remove this if we remove joints to worldframe
        push!(path, U.Bᵢ)
        path = get_body_path(U.Bᵢ, Us; path=path)        
    end    
    return path
end

function joint_path(Bs, Us)
    table = fill("", (length(Bs) + 1, length(Bs) + 1))
    bt = falses(length(Bs), length(Bs))
    #remove connections to N for now until we figure out what to do
    tmp_Us = Us[map(x->!isa(x.Bᵢ,WorldFrame),Us)]
    for U in tmp_Us
        table[1, U.G.id+1] = string(U.G.name) #label column
    end

    for B in Bs
        table[B.id+1, 1] = string(B.name) #label row                
        path = get_joint_path(B, Us)
        for Gᵢ in path
            table[B.id+1, Gᵢ.id+1] = "x" #mark inner body elements
            bt[B.id, Gᵢ.id] = true #mark inner body elements
        end
    end
    PathTable(table, bt)
end

#returns all bodies in another bodies path
function get_joint_path(Bₒ, Us; path=[]) #call without path, path is applied recursively
    U = find_U_by_Bₒ(Bₒ, Us)            
    if !isa(U.Bᵢ,WorldFrame)
        push!(path, U.G) # put back out of if once we figure out root_U
        path = get_joint_path(U.Bᵢ, Us; path=path)
    end
    return path
end
